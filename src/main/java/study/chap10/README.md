# 10. 테스트 코드와 유지보수

## 10.1 테스트 코드와 유지보수

사실상 CI/CD의 목적을 완벽히 달성하려면, 새로운 코드가 기존 기능을 망가뜨리지 않는지 검증해야 하며
이러한 측면에서 자동화 테스트는 CI/CD의 필수 요건 중 하나다.

테스트 코드도 '코드'이기 때문에 유지보수의 대상이다. 테스트 코드가 깨지는 데도 무시하고 배포하거나 주석처리하고 넘어간다면
테스트 코드는 가치를 잃는다. 코드에 버그가 발생했을 때 놓칠 가능성이 높아지는 것이다.

> 품질이 좋지 않은 테스트 코드를 작성함 -> 실패한 테스트를 통과시키기 위해 많은 노력이 필요함 -> 테스트 코드를 만들지 않게 됨 -> 테스트가 가능하지 않은 코드를 만들게 됨 -> 또 다시 테스트 코드 작성을 어렵게 만듦
-> 테스트 코드가 적음 -> 수동으로 테스트하는 범위가 증가함 -> 자동화 테스트에 비해 시간이 오래 걸림 -> 기존 코드에 문제가 있어도 놓칠 가능성 커짐

결국 악순환이다. 따라서 테스트 코드 자체의 유지보수성이 좋아야 한다. 그래야 지속적으로 테스트를 작성하게 되고, 결과적으로 소프트웨어 품질이 떨어지는 걸 방지할 수 있는 것이다.

## 10.2 테스트 코드 유지보수를 위한 주의 사항

1. [변수나 필드를 사용해서 기댓값 표현하지 않기](#변수나-필드를-사용해서-기댓값-표현하지-않기)
2. [두 개 이상을 검증하지 않기](#두-개-이상을-검증하지-않기)
3. [정확하게 일치하는 값으로 모의 객체 설정하지 않기](#정확하게-일치하는-값으로-모의-객체-설정하지-않기)
4. [과도하게 구현 검증하지 않기](#과도하게-구현-검증하지-않기)
5. [셋업을 이용해서 중복된 상황을 설정하지 않기](#셋업을-이용해서-중복된-상황을-설정하지-않기)
6. [실행 환경이 다르다고 실패하지 않기](#실행-환경이-다르다고-실패하지-않기)
7. [실행 시점이 다르다고 실패하지 않기](#실행-시점이-다르다고-실패하지-않기)
8. [필요하지 않은 값은 설정하지 않기](#필요하지-않은-값은-설정하지-않기)
9. [조건부로 검증하지 않기](#조건부로-검증하지-않기)
10. [통합 테스트는 필요하지 않은 범위까지 연동하지 않기](#통합-테스트는-필요하지-않은-범위까지-연동하지-않기)
11. [더 이상 쓸모 없는 테스트 코드](#더-이상-쓸모-없는-테스트-코드)

### 변수나 필드를 사용해서 기댓값 표현하지 않기

```java
    LocalDate date = LocalDate.of(1945, 8, 15);
    // 변수 사용
    assertEquals(date.getYear() + "년", dateStr);

    // 문자열 값 사용
    assertEquals("1945"년", dateStr);
```
- 기대하는 값을 명확하게 표현해야 한다.
- 변수를 사용하면 메서드를 잘못 사용할 수 있다.

> 근데 문자열도 오타가 생길 수 있지 않나? 싶었는데, 문자열 비교는 눈에 보이는 값으로 쉽게 가능하니 오류 확률이 더 낮다.
> 그러나 변수를 사용하면 내용물이 뭔지 모르므로 테스트를 실행해야만 확인할 수 있다는 불편함이 있다.
> 보통 변할 여지가 있는 경로 같은 경우는 변수로 나타내는 게 맞는데, 테스트 데이터 같은 하나의 예시 같은 경우에는
> 변하지 않는 값을 시각적으로 명확히 볼 수 있도록 코드를 작성하는 게 좋구나.

- 변수나 필드를 사용하면, **테스트를 처음 보는 사람이 왔다갔다하며 코드를 이해**해야 한다. 가독성이나 복잡성 측면에서 좋지 않다.

### 두 개 이상을 검증하지 않기

서로 다른 내용을 검증하는 단언문을 여러 개 작성하지 말라.
(예를 들어, 회원 가입 시 데이터가 저장되었는지 검증하고 이메일 발송을 요청했는지 검증하는 두 단언문을 넣는다면) 

왜?

- 만약 첫 번째 검증이 실패하면 테스트가 거기서 멈춘다.
- 결과에 대한 집중도가 떨어진다!! 실패했을 때 그 원인이 무엇일까? 또 한 번 생각해야 한다.

### 정확하게 일치하는 값으로 모의 객체 설정하지 않기

테스트가 **의도와 관련 없는 작은 변화에도 실패**해서는 안 된다.

```java
BDDMockito.given(mockPasswordChecker.checkPasswordWeak("pw"))
        .willReturn(true);

assertThrows(WeakPasswordException.class, () -> {
    userRegister.register("id", "pw", "email");
});
```
이 메서드는 코드를 `userRegister.register("id", "pww", "email");`와 같이 변경하면 실패한다.
이 테스트에서 중요한 건 비밀번호가 어떤 문자열인지가 아니라, 약한 비밀번호일 때 특정 예외를 던지는지 검증하는 게 목적인데.

따라서, 임의의 값에도 실패하지 않도록

```java
BDDMockito.given(mockPasswordChecker.checkPasswordWeak(Mockito.anyString()))
        .willReturn(true);
```
`Mockito.anyString()`을 사용할 수 있다.

- 모의 객체는 테스트 의도를 해치지 않는 범위에서 범용적인 값을 사용하여 기술하자.
- **유지보수성 측면**에서도, 테스트 코드 수정할 때 모의 객체 관련 코드를 함께 수정하지 않아도 된다.

### 과도하게 구현 검증하지 않기

**내부 구현을 검증하지 않도록 주의**하자.
이것이 나쁜 건 아니지만, 내부 구현을 검증한다면 **구현이 조금만 변경되어도 테스트가 깨질 위험이 높아진다.**
테스트 코드는 **실행 결과를 검증**해야 한다.

만약 기능을 검증할 방법이 구현 검증밖에 없다면
(`예를 들어, DAO 레거시 코드를 테스트해야 해서
메모리 이용 가짜 구현으로 대체하기 어렵다?`)
그렇게 해야 하지만, 점진적으로 결과를
검증할 수 있도록 수정해 나가야 한다.

### 셋업을 이용해서 중복된 상황을 설정하지 않기 😲

상황 구성을 위한 코드 중복을 `@BeforeEach` `setUp()` 메서드로 제거하면?
코드가 짧아지고 중복이 없어져서 코드 품질이 올라간 것처럼 보인다.

그러나, 테스트 코드에서는 이와 같은 방법이 새로운 문제를 야기할 수 있는데..!

- 테스트 작성 한참 이후 테스트가 실패해 다시 코드를 보게 되면, setUp() 메서드와 테스트 메서드를
왔다갔다하며 실패 원인을 분석해야 한다.
  
- 테스트가 깨지기 쉬운 구조가 된다! 모든 메서드가 동일한 상황 코드를 공유하기 때문이다.
setUp()을 변경할 때 영향을 받는 테스트가 어떤 어떤 것인지 파악해야 한다.

즉 **테스트 상황 구성이 한 군데 모여있지 않아서 발생하는 문제들**이 생긴다.
**시간이 지나면** 테스트 코드를 이해하고 유지보수하는 데 오히려 방해 요소가 된다.

테스트 메서드는 검증을 목표로 하는 하나의 완전한 프로그램이어야 한다. 각 메서드는 별도 프로그램으로서
**검증 내용을 스스로 잘 설명할 수 있어야 한다.**

```java
@BeforeEach
void setUp() {
    changeService = new ChangeUserService(memoryRepository);
}

@Test
void noUser() {
    assertThrows(
            UserNotFoundException.class,
            () -> changeService.changeAddress("id", new Address("서울", "남부"))
    );
}

@Test
void changeAddress() {
    memoryRepository.save(
            new User("id", "name", new Address("서울", "북부"))
    );
    
    changeService.changeAddress("id", new Address("경기", "남부"));
    
    User user = memoryRepository.findById("id");
    assertEquals("경기", user.getAddress().getCity());
}

```
위와 같이 상황 구성을 별도로 하면, 코드는 길어지지만 테스트 메서드가 스스로를 더 잘 설명하게 된다.
유저가 없는 상황, '서울 북부'가 주소지인 유저가 존재하는 상황 등 별도의 상황 설정이 필요한 다양한 테스트가 가능해진다.

(무조건 짧다고 좋은 게 아니다!)

#### 통합 테스트에서 데이터 공유 주의하기

DB 환경 구성을 위한 sql 초기화 역시, 특정 테스트 메서드에서만 필요한 데이터일 경우
특정 테스트에서만 생성해야 한다.

또한, 통합 테스트 상황 설정을 위해 **보조 클래스**를 사용할 수 있다.
예를 들어 값만 입력하면 sql 쿼리를 날릴 수 있도록 미리 클래스와 메서드를 만들어두면 코드 중복을 없애면서도
테스트마다 상황을 구성할 수 있다.

### 실행 환경이 다르다고 실패하지 않기

- 파일 경로: 프로젝트 디렉토리를 기준으로 설정한다.
- 특정 운영체제에 국한된 테스트: `@EnabledOnOS`, `@DisabledOnOS` 애노테이션을 사용할 수 있다.

### 실행 시점이 다르다고 실패하지 않기

- 테스트 코드에서 시간을 명시적으로 제어할 수 있도록 만들기
  - 현재 시각과 같은 데이터 사용하지 않기

- 별도의 시간 클래스 / 랜덤 값 제공 클래스 작성하기
  - 테스트 코드에서는 이 클래스를 상속받아 제어할 수 있도록 만들기

### 필요하지 않은 값은 설정하지 않기

```java
@Test
void dupIdExists_Then_Exception() {
    memomryRepository.save(User.builder().id("dupId").build());
    
    RegisterReq req = RegisterReq.builder()
            .id("dupId")
            .build();
    
    assertThrows(DupIdException.class,
            () -> userRegisterSvc.register(req)
    );
}
```
중복 Id를 검증한다면 불필요한 이메일, 이름과 같은 값을 지정하지 마라. '뭐라고 짓지...' 생각할 시간도 줄어든다.

필수 값이 많고, 값에 따라 결과가 달라져 다양하게 생성해야 하는 테스트 객체라면 **팩토리 클래스**와 **빌더 패턴**을 잘 활용하라.

- 코틀린이 편한 이유: 파라미터의 기본 값을 지원할 수 있음. 이 경우 팩토리 메서드를 다음과 같이 구성 가능

```kotlin
import java.time.LocalDate
import java.time.LocalDateTime

fun createTestSurvey(
  id: Long = 1L, title: String = "제목", status = SurveyStatus.READY,
  endOfPeriod: LocalDateTime = LocalDateTime.now().plusDays(5),
  questions: List<Question> = listOf(
    Question(1, "질문1", listOf(Item(1, "보기1"), Item(1, "보기2"))),
    Question(2, "질문2", listOf(Item(1, "답1"), Item(1, "답2"))),
  )
): Survey {
    return Survey.builder()
      .id(id).title(title).status(status)
      .endOfPeriod(endOfPeriod)
      .questions(questions)
      .build()
}

@Test
fun answer() {
    memorySurveyRepository.save(
        createTestSurvey(id = 10L, status = SurveyStatus.OPEN)
    )
}
```
~~코틀린을 배워야겠다 재밌겠다~~

### 조건부로 검증하지 않기

테스트는 성공하거나 실패해야 한다! 조건에 따라 단언을 하지 않게 되면 이상한 테스트가 되어버린다.

### 통합 테스트는 필요하지 않은 범위까지 연동하지 않기

귀찮아서 자주 저질렀던 일인데, 다음 코드를 보자.

```java
@SpringBootTest
public class MemberDaoIntTest {
    // DB와 연동을 처리하는 MemberDao를 테스트한다.
}
```
위 애노테이션은 서비스, 컨트롤러 등 모든 스프링 빈을 초기화한다.
DB 관련 설정 외에도 초기화하게 되므로 테스트 시간이 길어진다. _(경험 상, 서비스에 오류가 있는 등 당장 검증할 부분이 아닌데 잘못된 코드가
있다면 고쳐야 하는 등 테스트에서 신경 쓸 부분이 많아져 더 시간을 많이 잡아먹는다.)_
이 경우 `@JdbcTest`, `@AutoConfigureTestDatabase` 등 필요한 것만 초기화하도록 하자.

### 더 이상 쓸모 없는 테스트 코드

- 특정 클래스의 사용법을 익히기 위해 작성한 테스트 코드
- 테스트 커버리지를 높이기 위해 작성한 테스트 코드(실제로 품질 향상에 도움이 안 됨)

이런 테스트는 제거해야 한다.

> 커버리지를 높이기 위해서는 현재 테스트가 다루지 않는 if-else나 하위 타입을 찾아 테스트를 추가해야 한다.