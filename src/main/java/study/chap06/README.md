### 6. 테스트 코드의 구성

왜 **상황**이 중요하지? 테스트 코드는 항상 일관된 결과를 유지해야 한다. 상황에 따라 달라지면 안 된다.

#### 6.1. 테스트 코드 구성 요소: 상황, 실행, 결과 확인

- 기능은 '상황'에 따라 달라진다. 이에 따라 변화할 수 있는 요소들에 대응하는 것이 소프트웨어 품질을 높이는 일
- 따라서 테스트 코드는 상황, 실행, 결과 확인 (given, when, then)으로 구성

##### 상황은 어떻게 설정하지?

- 객체 생성
- `@BeforeEach`
- 결과에 영향을 주는 상황이 존재하지 않는 경우도 있다. 이럴 때에는 테스트가 기능 실행, 결과 확인만 포함

##### 상황 설정이 외부에서 진행된다면?

- 외부: 파일, DBMS, 외부 서버 등

예를 들어 파일을 읽어오는 메서드가 있다면, 그 상황은 '파일'이라는 외부에서 설정된다.

- 미리 테스트 파일을 준비하는 방법. 파일이 없어야 한다면 명시적으로 파일을 지우고 시작하는 메서드 추가.
- 코드 실행 시 테스트 파일을 준비하도록 테스트 코드를 짜는 방법. 이게 더 명시적인 환경 설정
- 테스트 파일 역시 버전 관리에 잘 포함시켜야 한다.

##### 외부 상태가 테스트 결과에 영향을 주지 않게 하기

- 테스트 실행 전 외부를 원하는 상태로 만들어 놓는 코드 (e.g. 데이터베이스 행 추가, 삭제)
- 테스트 메서드 실행 후 트랜잭션 롤백

##### 하지만! 언제나 외부 상태를 제어할 수 있는 것도 아니다.

- 외부 업체와 협력하여 DB를 쓰는데 insert, select 권한만 있을 경우, 외부 API를 쓸 경우..

이럴 때는 **대역**을 사용하면 테스트 작성이 쉬워진다.

* **대역**: 테스트 대상이 의존하는 대상의 실제 구현을 대신하는 구현