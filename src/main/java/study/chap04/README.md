### 4. TDD, 기능 명세, 설계

#### 4.1. 기능 명세

- 기능은 크게 두 가지: **입력, 결과**

```
    입력: 아이디와 암호
    결과: 아이디와 암호가 일치하면 성공, 아니면 실패
```

- 결과: 리턴 값, 익셉션, 시스템의 상태 변경(DB 등)
  - **시스템의 상태 변경이 결과에 포함된다면 테스트는 변경 대상에 접근해 결과를 확인해야 함**
- 기능 명세의 입력과 결과를 코드에 반영하는 과정에서 기능의 이름, 파라미터, 리턴 타입 등이 결정. -> 기능에 대한 설계

#### 4.2. 설계 과정을 지원하는 TDD

- TDD의 시작은 당연히 테스트 만들기

1. 테스트할 기능 실행
2. 실행 결과를 검증

따라서, 클래스/메서드/함수의 이름/파라메터/리턴 값을 정의해야 한다. 

1. 클래스의 이름 선택
2. 여기서 호출할 메서드가 무엇인가
3. 해당 메서드의 이름, 파라미터, 리턴 값 결정

이러한 사고는 자연스럽다. 즉 테스트 작성 과정은 곧 일부 **설계** 행위이다.

> 잘못 지은 이름은 두고두고 개발자를 속인다. 생산성 저하로 이어질 수밖에 없다.
> 요즘 이름 고민을 열심히 한다. 무엇보다 중요한 것은 결국 '우리 팀'이 알아봐야 한다는 것이다.

#### 4.3. 필요한 만큼 설계하기

- 테스트를 통과할 만큼만 코드를 작성한다.
- 테스트는 설계와 일맥상통. **필요할 것으로 예측해서 미리 설계를 유연하게 만들지 않는다.**

> 왜? 그나마 당장 떠오르는 건 유연한 설계를 위해 마련해둔 인터페이스가 일을 더 크게 벌렸던 경험.

- **설계가 불필요하게 복잡해지면 안 되기 때문이다.** 지금의 설계는 초안에 불과하기 때문이다. 따라서 유연한 설계 역시 필요할 때에 도입하라.

> 요즘 유연한 설계에 대한 고민을 계속 해왔는데, 꼭 필요한 말이다.
> 1. 유연한 설계가 늘 복잡한 것은 아니라고 생각한다. 오히려 당장 필요한 설계만 생각하다가 이후 유지보수 비용이 너무 많이 들어 생산이 중단되는 경우도 있었다. 좀 더 분석해보면, 이 경우는 설계의 문제보다 '구현'의 문제라고 본다. 적절한 설계가 우선되지 않아 구현이 복잡성을 낳은 결과였다.
> 2. 요구사항의 변동이 잦은 프로젝트에서 유연한 설계를 고민한 덕분에 변화에도 큰 코드 수정 없이 대응할 수 있었다. 데이터베이스 스키마 설계, 모듈의 책임 분리 등이 그렇다.
> 3. 반면, 새로운 LLM이 도입될 수도 있다는 확장성을 기대했던 인터페이스 도입은 오히려 복잡한 설계를 만들었었다.
> 4. 요구사항에 적합한 설계 경험으로는 DTO 구조 설계가 있다. 모든 응답과 요청을 분리한다면 확장성이 좋았겠지만, 큰 리소스가 들고 실제로 요구되는 바도 아니었다. 필요할 때 필요한 설계를 했었다.
> 경험을 바탕으로 내린 결론은, 너무 먼 미래를 내다봐서도 안 되고 코앞만 생각해서도 안 된다. 그렇기에 문제를 바라보는 시각이 정말 중요하다. 문제를 바라보는 '개발자'로서의 시각을 갖춰야 한다.

#### 4.4 기능 명세 구체화

- 기능 명세 문서는 필요한 게 맞다. 또한 개발자는 여기서 기능의 입출력을 도출한다. 애매한 점은 기획 또는 실무 담당자와 얘기해 구체적인 정리가 필요하다.

> 내가 했던 질문의 예시들) 북카이브에서 태그는 대소문자, 공백을 구분하는가? '기록'은 어떤 행위로 정의되는가? 책 추가에서 필수로 존재해야 하는 값은? '검색' 기능의 입력은 어디까지 커버해야 하는가?

- '예시'는 기능 명세를 구체화한다. 정의를 위해서는 예시가 필요.

- 모호한 상황은 구체적인 예시로 바꿔 테스트 코드에 반영하라.

즉 테스트 코드는 예를 이용한 구체적인 명세이다. 따라서 **문서화**의 기능을 하는 것.

> 나는 테스트 코드를 작성할 때 예시가 아닌 일반화된 기능을 먼저 생각했던 것 같다.
> 예를 끄집어내는 데 좋은 방법은 '담당자와의 대화'이다.
